# 27장: 배열

- [27장: 배열](#27장-배열)
  - [27-1. 배열이란?](#27-1-배열이란)
  - [27-2. 자바스크립트 배열은 배열이 아니다](#27-2-자바스크립트-배열은-배열이-아니다)
  - [27-3. length 프로퍼티와 희소 배열](#27-3-length-프로퍼티와-희소-배열)
  - [27-4. 배열 생성](#27-4-배열-생성)
    - [1. 배열 리터럴:](#1-배열-리터럴)
    - [2. Array 생성자 함수:](#2-array-생성자-함수)
    - [3. Array.of:](#3-arrayof)
    - [3. Array.from:](#3-arrayfrom)

---

## 27-1. 배열이란?

-   배열 내부의 값을 '요소'(Element)라고 부르며, 자바스크립트에서는 모든 값이 배열의 요소가 될 수 있다
-   배열이라는 별도의 타입이 존재하지 않는다 (배열은 객체 타입)
-   일반 객체와 배열의 가장 명확한 차이는 '값의 순서'와 'length' 프로퍼티다 (둘 덕분에 값에 순차적으로 접근하기 적합한 자료구조라 볼 수 있음)

<br>

## 27-2. 자바스크립트 배열은 배열이 아니다

> "자바스크립트의 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체다." (p.496)

-   흔히 자료구조에서 말하는 배열은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조를 말한다. 이를 위해 자료구조의 배열의 요소들은 하나의 데이터 타입으로 통일되어 있고 연속되어 있는데, 이를 **밀집 배열(Dense Array)**라 한다
-   즉, 선두 Address와 데이터의 크기를 알면 다른 요소의 위치를 알 수 있다 (고로 random access에 장점이 있다 `O(1)`)
-   자바스크립트에서 배열의 요소를 위한 각각의 메모리 공간은 동일한 크기여야 하지 않으며, 연속적으로 이어져 있지 않을 수도 있다. 이를 **희소 배열(Sparse Array)**라 한다
-   다시 말해 자바스크립트 배열은 요소의 추가/삭제의 속도를 위해(실사용에 더 유리함) readonly 배열일 때의 속도를 포기한 것이라고 볼 수 있다

```
일반 배열 vs 자바스크립트 배열

1. 일반적인 배열은 인덱스로 요소에 빠르게 접근할 수 있음
 - 단, 요소를 삽입/삭제하는 경우 효율적이지 않음
 - 중간에 요소 추가시, 뒤에 있는 요소를 다 옮기고 추가해야 한다

2. JS 배열은 인덱스로 요소에 접근하는 경우 일반 배열볻 성능면에서 느리다
 - 자바스크립트 배열은 해시 테이블로 구현된 객체이기 때문이다
 - 하지만 요소를 삽입/삭제하는 경우에는 일반적인 배열보다 빠른 성능을 기대할 수 있다
```

-   위에서 언급된 단점을 보완하기 위해 모던 JS Engine은 배열을 일반 객체와 구별하여 좀 더 배열처럼 동작하도록 최적화되었다

<br>

## 27-3. length 프로퍼티와 희소 배열

-   length 프로퍼티는 요소의 개수(배열 길이)를 나타내는 0 이상의 정수를 값으로 가짐
-   length 프로퍼티는 배열에 요소가 추가되거나 삭제되면 자동 갱신된다
-   명시적으로 length 프로퍼티를 할당할 수 있다. 기존 length 보다 작은 수가 할당된 경우 배열이 잘리고, 더 큰 수가 할당된 경우에는 배열의 길이가 늘어나지는 않고 `<empty item>`이 들어오게 된다 (희소 배열)
-   `<empty item>`은 실체가 없다. 즉, 메모리 공간이 확보되거나 빈 요소가 생성된 것은 아니다
-   배열을 사용할 때는 희소 배열을 사용하지 않는 것이 중요하므로 배열에 `<empty item>`을 사용하거나 다른 타입의 요소를 위치시키는 것은 적절하지 않다

<br>

## 27-4. 배열 생성

### 1. 배열 리터럴:

```javascript
// 대괄호([])로 묶어서 사용하는 가장 편리한 배열 리터럴 방식
const favoriteFruits = ["banana", "strawberry", "tangerine"];

// 요소를 하나도 추가하지 않으면 length 프로퍼티가 0인 배열이 된다
const favoriteFood = [];

// 요소 생략 시 희소 배열이 생성된다
const numbers = [1, , 3]; // [1, empty, 3]
console.log(numbers[1]); // undefined
```

### 2. Array 생성자 함수:

```javascript
// 1. 인수 하나 전달
const singleParamArray = new Array(10); // [empty * 10]

// 2. 인수 2개 이상
const multiParamArray = new Array(1, 2, 3, 4); // [1, 2, 3, 4]
```

### 3. Array.of:

```javascript
// 1. 인수 하나 전달
const singleParamArrayOf = Array.of(1); // [1]

// 2. 인수 2개 이상 전달 (즉, 1개일 때랑 같이 동작함)
const multiParamArrayOf = Array.of(1, 2, 3, 4); // [1,2,3,4]
```

### 3. Array.from:

```javascript
Array.from({ length: 2, 0: "a", 1: "b" }); // --> ['a', 'b']

Array.from("Hello"); // --> ['H', 'e', 'l', 'l', 'o']
```

-   Array.from 메서드는 유사 배열 객체 또는 이터럴블 객체를 인수로 받아 배열로 변환하여 반환한다

```javascript
Array.from({ length: 0 }, (_, i) => i); // [0, 1, 2]
```

-   두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다
-   두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다

<br>

---

-   배열 메서드는 원본 값을 변경시키는 mutator 메서드, 변경시키지 않는 accessor 메서드로 나뉜다
-   최대한 mutator 메서드를 피하고 accessor 메서드를 사용하는 것이 올바르다
-   특히, `map`과 `filter`를 사용해서 해결 가능한 경우 최우선으로 사용해야 한다
