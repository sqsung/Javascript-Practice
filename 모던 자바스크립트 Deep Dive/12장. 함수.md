# 12장: 함수

> 자바스크립트 함수는 수학의 함수와 같은 개념으로, 일련의 과정을 문(Statement)으로 구현하고 코드 블럭으로 감싸서 하나의 실행 단위로 정의한 것이다

<br>

## 12-1. 함수란? 

- 함수의 요소는 매개변수(Parameter), 인수(Argument), 출력값(return value), 그리고 (함수는 하나의 값이며 여러 개 존재할 수 있으므로) 식별자인 함수명이 있다 

```javascript
function addTwoNums(x, y) { // addTwoNums = 함수명, x, y = 매개변수
    return x + y; // 'x + y' = 반환값  
}

addTwoNums(3, 3); // 3, 3 = 인수 
```

<br>

## 12-2. 함수를 사용하는 이유 

- 함수는 여러 번 호출할 수 있다. 즉, 여러 번 수행해야 하는 일련의 과정이 있다면, 이 과정을 함수로 묶어두고 사용하는 것이 **코드의 재사용** 측면에서 매우 유리하다 
- 또한 '일련의 과정'을 반복적으로 여러 번 코드로 작성하다 보면 실수가 발생할 수도 있고, 코드 유지보수도 어려워진다. 
- 코드는 객체 타입의 값이므로 식별자인 함수명을 붙일 수 있다. 적절한 함수 이름을 사용하는 것이 코드 가독성을 향상시키고 협업을 돕는다 

<br>

## 12-3. 함수 리터럴 
- 앞서 언급했듯 함수는 객체 타입의 값이므로 리터럴로 생성할 수 있다 

```javascript 
// 변수에 함수 리터럴을 할당하는 '함수 표현식' 
// '함수 정의' 부분 참고 

let myFunc = function(x, y) {
    return x + y;
}; 
```
- 함수명의 사용은 옵션이며, 사용해도 함수 내부에서만 참조할 수 있는 식별자이다 (함수 리터럴을 사용한 '함수 표현식' 방식으로 함수를 생성하는 경우. 추후 **함수 선언문**부분 참고)
- 함수는 일반 객체와는 다른 객체다 (일급 객체). 일반 객체는 호출할 수 없지만 함수는 호출할 수 있으며, 함수는 일반 객체에는 없는 함수만의 고유한 프로퍼티를 갖는다

<br>

## 12-4. 함수 정의
- 총 4가지의 함수 정의(like 변수 선언) 방식이 있다
```javascript
// 1. 함수 선언문 

function add(x, y) {
    return x + y;
}

// 2. 함수 표현식 

var add = function(x, y) {
    return x + y;
};

// 3. Function 생성ㅅ자 함수 

var add = new Function('x', 'y', 'return x + y');

// 4. 화살표 함수(ES6)

var add = (x, y) => x + y;
```

### A. 함수 선언문: 
- 함수 리터럴과 형태는 비슷하지만, 함수명 생략이 가능한 함수 리터럴과 달리 함수 선언문은 이름 생략이 불가하다 
- 함수 선언문은 '표현식인 문'이 아니다 (개발자 도구에 찍어보면 undefined)
- 표현식이 아니기 때문에 변수에 할당할 수 없어야 정상이지만, 아래 예제를 보면 변수에 할당하여 사용할 수 있는 것처럼 보인다 

```javascript 
var add = function add(x, y) {
    return x + y;
};

console.log(add(3, 8)); // --> 11 
```
- 이는 함수 리터럴이 중의적인 코드이기 때문이다. 자바스크립트 엔진이 중의적인 코드를 만나는 경우, 코드의 문맥에 따라 코드를 암묵적 해석한다
- 즉, 함수 이름이 있는 함수 선언문이 피연산자로 사용되는 등 자바스크립트 엔진이 함수 선언문을 함수 리터럴로 해석할 여지가 있는 경우에는 함수 리터럴로 자체 해석하여 사용한다 

```javascript 
// *기명 함수 리터럴을 단독 사용하면 '함수 선언문'으로 해석된다 
// *함수 선언문에는 함수명이 생략 불가하다 

function foo() {
    console.log('foo');
}

foo(); // --> "foo" 
// 기명 함수 리터럴이 단독으로 사용되어 함수 선언문으로 해석되었다 
```

- 같은 함수 그룹 연산자의 피연산자로 사용하면 함수 리터럴로 해석한다 

```javascript 
(function bar() {
    console.log('bar'); 
});

bar(); // --> ReferenceError: bar is not defined 
```
- 같은 함수를 변수에 할당해도 함수 리터럴로 해석될 뿐, 함수명으로 함수를 호출할 수 없다 
```javascript 
var myFunc = function add(x, y) {
    return x + y;
};

add(); // --> ReferenceError
```
- 즉, 기명 함수의 경우 코드 문맥에 따라 함수 리터럴이나 함수 선언문으로 자체 해석될 수 있으므로 참고해서 사용하는 것이 올바르다
- 또한 함수 선언문과 리터럴은 함수 객체를 생성한다는 점에서는 동일하지만, 호출 방식에 차이가 있다 
- 왜냐면 앞서 언급했듯이 함수명은 (원래는) 함수 몸체에서만 참조할 수 있는 식별자이다. 즉, 선언문으로든 리터럴로든 어떠한 메모리 공간 안에 함수 객체가 생성되는 것은 동일하지만, 해당 메모리 공간을 가리키는 식별자가 없다는 소리다 

![Copy of age (4)](https://user-images.githubusercontent.com/112310899/210784540-e2328942-1ab7-4c05-9fd3-ed2f86af1829.png)

- 그렇다면 함수 선언문을 사용해도 함수명으로 함수를 호출할 수 없는 것이 일반적이겠지만, 함수 선언문 방식으로 함수 객체를 정의하게 되면 자바스크립트 엔진이 암묵적으로 **함수명과 동일한 이름의 식별자를 생성하고, 해당 식별자를 통해 함수 객체를 할당한다** 
- 즉, 함수명으로 함수가 호출되는 것처럼 보일 뿐 사실 암묵적으로 생성된 함수명과 동일한 식별자를 사용해 함수를 호출하고 있는 것이다 

### B. 함수 표현식:

- 자바스크립트에서 함수는 **일급 객체**(값의 성질을 갖는 객체)이므로, 함수를 값처럼 자유롭게 사용할 수 있다 
- 이 점을 활용해서 변수에 함수 리터럴을 할당하여 함수 객체를 정의하는 정의 방식을 **함수 표현식**이라고 한다 

```javascript 
var addTwoNums = function(x, y) {
    return x + y;
};
```
- 함수 선언문과 함수 표현식에는 중요한 차이점이 있는데, 그것은 둘의 생성 시점이 다르다는 점이다 
- **호이스팅**으로 인해 자바스크립트에서는 모든 선언문이 런타임 전에 우선 실행되는데, 함수도 예외는 아니다 (함수 호이스팅) 
- 다만 `var` 키워드를 사용한 함수 표현식의 경우 `var` 키워들 통해 선언된 변수와 같이 undefined로 초기화된다
- 반면 함수 선언문을 통해 정의된 함수는 undefined로 초기화 되지 않고, 처음부터 함수 객체로 그 자체로 초기화된다 
- 그래서 동일한 기능을 가진 함수임에도 불구하고, 어떤 방식으로 정의되었냐에 따라서 선언 전에 참조될 수 있는지 없는지가 결정된다 

```javascript 
console.log(add); // --> [Function: add]
console.log(sub); // --> undefined 

console.log(add(1, 2)); // --> 3
console.log(sub(2, 1)); // --> Error 

// A. 함수 선언문으로 정의된 add 함수
function add(x, y) {
    return x + y;
}

// B. var 키워드 사용한 함수 표현식으로 정의된 sub 함수
var sub = function(x, y) {
    return x - y;
};
```
- 함수 선언문으로 정의된 `add` 함수만 선언 전에 참조가 이뤄져도 실행된다
- 이것이 함수 선언문의 장점이라기 보다는 당연히 단점이므로, <JavaScript: The Good Parts>의 저자이자 JSON을 창안한 Douglas Crockford는 함수 선언문 대신 함수 표현식을 사용하는 것을 권장한다 

### C. Function 생성자 함수:
- Function 생성자 함수를 통해 정의된 함수는 closure를 생성하지 않는 등 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다 
- Function 생성자 함수를 사용하는 것은 일반적이지도, 바람직하지도 않다 

```javascript
new Function('x', 'y', 'return x + y');
```

### D. 화살표 함수: 
- 화살표 함수는 항상 익명으로 정의한다 
- 화살표 함수는 기존의 함수 선언문/표현식을 완전히 대체하고자 디자인된, 단순히 문법이 간략한 함수 정의 방식이 아니다. 내부 동작 자체가 간략화 되어 있다 (추후 화살표 함수 참고)

```javascript 
let addTwoNums = (x, y) => x + y;
```

<br>

## 12-5. 함수 호출 

### 매개변수와 인수: 
- 매개변수는 몸체 내부에서만 참조할 수 있는 변수이다 
- 매개변수의 개수에는 (제한이 있긴 있지만) 거의 무제한으로 사용할 수 있으나, 코드 가독성, 유지성 측면에서 적을 수록 좋다 
- 매개변수가 많이 필요하다면 인수로 객체를 전달하는 것이 더 적절하다
- 인수는 순서에 맞게 매개변수로 입력되며, 매개변수보다 인수의 개수가 더 많거나 적어도 별다른 에러가 발생하지는 않는다 

### 인수 확인: 
- 자바스크립트는 함수의 매개변수와 인수의 개수가 일치하는지 확인하지 않으며, 매개변수의 타입을 사전에 지정할 수 없다 

```javascript 
// 개발자 의도: 숫자 2개의 합을 계산하고자 함 
var add = function(x, y) {
    return x + y;
};

add(1, 2); // --> 3
add('a', 'b'); // --> "ab" (의도한 타입과 다른 인수를 받자 다르게 동작함)
```

### 반환문:
- 함수 내부에 `return`을 사용해서 반환 값을 지정할 수 있으며, return 이후의 코드는 동작하지 않는다 
- return과 반환 값 사이에 줄바꿈이 있는 경우 ASI로 인해 return 다음 `;`이 찍히게 되면서 반환 값이 계산되지 않는다
```javascript 
function addTwoNums(x, y) {
    return // return; 이 되므로 undefined 가 반환됨 
    x + y;
}
```
- 오직 함수 몸체에서만 사용할 수 있다 

<br>

## 12-6. 참조에 의한 전달과 외부 상태의 변경 
- 함수의 매개변수 또한 일반 변수처럼 원시/객체 값 여부에 따라 값에 의한 전달/참조에 의한 전달이 이뤄진다 
- 원시 값 인수는 함수 내 어떤 일이 있어도 원본 값(함수 외부에서 전달된 원본 값)이 영향을 받지 않지만, 객체가 전달된 경우에는 원본 값이 변경될 수 있다 

```javascript 
function changeVal(primitive, obj) {
    primitive += 20;
    obj.name = "Kim";
}

var num = 80; 
var obj = {};

changeVal(num, obj);

console.log(num); // --> 80 (함수가 실행되었음에도 원본 값 유지됨)
console.log(obj); // --> { name: "Kim" } (함수 실행되었더니 원본 값 변경됨)
```
- 이를 방지하기 위해 객체 상태를 불변으로 변경해 사용하기도 한다 
- 이렇게 외부의 상태를 변경하지도, 외부 상태에 의존하지도 않는 함수를 `순수 함수`라 부른다 

<br>

## 12-7. 다양한 함수의 형태 
### A. 즉시 실행 함수:
```javascript
(function() {
    var a = 3;
    var b = 5;
    return a * b;
}());
```
- 즉시 실행 함수는 함수 정의와 동시에 실행되는 함수이다 
- 단 한번만 호출되며 다시 호출할 수 없다 
- 익명으로 사용하는 것이 일반적이나, 기명으로 사용할 수는 있다. 다만 그룹 연산자 내 피연산자로 있는 기명 함수는 함수 리터럴로 평가되기 때문에 어차피 함수명을 사용한 재호출은 불가능하다 

### B. 재귀 함수 
```javascript 
var factorial = function foo(n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```
- 함수가 자기 자신을 호출하는 것을 '재귀 호출'이라 하며, 이렇게 재귀 호출을 하는 함수를 '재귀 함수'라 한다 
- 재귀 함수는 주로 for/while 문을 사용해서 표현할 수 있다. 탈출 조건이 제대로 동작하지 않는 경우 함수가 무한 호출되며 스택 오버플로우가 발생할 위험이 큰 재귀 함수는 사용이 더 직관적이고 이해하기 쉬울 때만 한정적으로 사용한느 것이 적절하다 

### C. 중첩 함수: 
```javascript 
function outerFunc() {
    var x = 1;

    function innerFunc() {
        var y = 2;
        console.log(x + y); 
    }

    innerFunc();
}

outerFunc(); // --> 3
```
- 함수 내부에 다른 함수가 정의되어 있는 경우 중첩 함수라 한다 
- 주로 내부 함수가 외부 함수의 헬퍼 함수인 경우가 많다 

### D. 콜백함수: 
- 콜백 함수: 매개변수로 타 함수에 전달되는 함수
- 고차 함수: 콜백 함수를 전달받는 함수 
- 중첩함수처럼 헬퍼함수가 내부에 있는 경우 교체하기 어려운 경우가 많지만, 콜백함수는 함수 외부에 있으므로 상대적으로 유지하기 쉽다는 장점이 있다 
- 고차함수가 자주 호출되거나, 콜백 함수가 다른 곳에서도 호출되어야 하는 경우에는 함수 외부에서 콜백함수를 정의한 후, 함수 참조를 고차 함수에 넘겨주는 것이 낫다. (콜백 함수로 전달되는 함수 리터럴은 호출될 때 마다 평가되어 함수 객체를 새로 생성하기 때문)
