# 34장: 이터러블

-   [34장: 이터러블](#34장-이터러블)
    -   [34-1. 이터레이션 프로토콜](#34-1-이터레이션-프로토콜)
        -   [이터러블(Iterable)](#이터러블iterable)
        -   [이터레이터(Iterator)](#이터레이터iterator)
    -   [34-2. 빌트인 이터러블](#34-2-빌트인-이터러블)
    -   [34-3. for...of문](#34-3-forof문)
    -   [34-5. 이터레이션 프로토콜의 필요성](#34-5-이터레이션-프로토콜의-필요성)

---

## 34-1. 이터레이션 프로토콜

-   (ES6) 이터레이션 프로토콜은 순회 가능한 자료구조를 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다
-   **이터러블 프로토콜**: `[Symbol.iterator]`을 키로 갖는 메서드를 프로토타입 메서드로 상속 받은, 혹은 직접 개발된 메서드를 호출하면 이터레이터 프로토콜을 준수한 인터레이터를 반환한다. 이터러블 프로토콜을 준수한 객체를 '이터러블'이라고 한다
-   **이터레이터 프로토콜**: 이터레이터는 `next` 메서드를 소유하고, `next` 메서드를 호출하면 이터러블을 순회하며 `value`와 `done` 프로퍼티를 갖는 이터러블 리절트 객체를 반환한다. 이터레이터 프로토콜을 준수한 객체를 '이터레이터'라 한다

```
💡이터러블에서 이터레이터 리절트 객체까지의 흐름

1. 이터러블(Iterable) : 자료구조
- [Symbol.iterator]() {} 메서드 소유

-------- [Symbol.iterator] 메서드 호출 --------

2. 이터레이터(Iterator) : 객체
- next() {} 메서드 소유

-------- next 메서드 호출 --------

3. 이터레이터 리절트 객체(Iterator Result Object) : 객체
- value (현재 순회 중인 값), done (순회 완료 여부) 프로퍼티 보유
- eg) { value: 1, done: false }
```

### 이터러블(Iterable)

-   `[Symbol.iterator]`을 프로퍼티 키로 사용한 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체를 말한다
-   예) 배열은 `Array.prototype`의 `[Symbol.iterator]` 메서드를 상속받는 이터러블이다
-   이터러블 자료구조는 for...of문으로 순회할 수 있으며, 스프레드 문법과 디스트럭처링 할당의 대상으로 사용할 수 있다
-   `[Symbol.iterator]` 메서드가 직접 구현되어 있지 않거나 별다른 상속을 받지 않은 일반 객체는 이터러블이 아니다 (즉, for...of문으로 순회 불가능)

```javascript
const obj = { a: 1, b: 2 };
const objCopy = { ...obj };

console.log(obj); // { a: 1, b: 2 }
console.log(objCopy); // { a: 1, b: 2 }
console.log(obj === objCopy); // false
```

-   단, 일반 객체에 스프레드 문법 사용은 허용되었다
-   또한, 일반 객체도 '이터러블 프로토콜'을 준수하도록 구현하면 이터러블이 된다

### 이터레이터(Iterator)

```javascript
const array = [1, 2, 3];
const iterator = array[Symbol.iterator]();

console.log("next" in iterator); // true

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

-   이터러블의 `[Symbol.iterator]` 메서드를 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다
-   이터레이터는 next 메서드를 갖는다
-   next 호출 시 이터러블을 순차적으로 순회하며 결과를 나타내는 이터러블 리절트 객체를 반환한다
-   이터러블 리절트 객체의 value 프로퍼티는 현재 순회 중인 이터러블 값, done은 순회 완료 여부를 나타낸다
-   done 프로퍼티는 마지막 순회까지 'false'로 되어 있으며, 순회 범위에서 벗어난 경우에만 value는 'undefined', done 프로퍼티는 'true'가 된다

<br>

## 34-2. 빌트인 이터러블

-   Array, String, Map, Set, TypedArray, arguments, DOM컬렉션은 모두 빌트인 이터러블이다

<br>

## 34-3. for...of문

-   for...of문은 내부적으로 이터레이터의 'next' 메서드를 호출하며 반환된 이터레이터 리절트 객체의 'done' 프로퍼티가 true일 때까지 이터러블을 순회한다

<br>

## 34-5. 이터레이션 프로토콜의 필요성

-   ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 이터러블로 통일하여 for...of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용할 수 있도록 했다
-   이터러블은 데이터 공급자, for...of문/디스트럭처링 등은 데이터 소비자라고 볼 수 있다
-   만약 다양한 데이터 공급자가 각자의 순회 방식을 갖는다면 데이터 소비자는 다양한 데이터 공급자의 순회 방식을 모두 지원해야 하므로 매우 비효율적이다
-   이터레이션 프로토콜로 순회 방식이 통일된 덕분에 데이터 소비자는 이터레이션 프로토콜만 지원하도록 구현될 수 있다는 효율성이 큰 장점이다
-   즉, 이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 한다
