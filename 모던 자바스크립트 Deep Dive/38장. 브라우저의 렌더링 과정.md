# 38장: 브라우저의 렌더링 과정

-   [38장: 브라우저의 렌더링 과정](#38장-브라우저의-렌더링-과정)
    -   [38-1. 요청과 응답](#38-1-요청과-응답)
    -   [38-2. HTTP 1.1과 HTTP 2.0](#38-2-http-11과-http-20)
    -   [38-3. HTML 파싱과 DOM 생성](#38-3-html-파싱과-dom-생성)
    -   [38-4. CSS 파싱과 CSSOM 생성](#38-4-css-파싱과-cssom-생성)
    -   [38-5. 렌더 트리 생성](#38-5-렌더-트리-생성)
    -   [38-6. 자바스크립트 파싱과 실행](#38-6-자바스크립트-파싱과-실행)
    -   [38-8. 자바스크립트 파싱에 의한 HTML 파싱 중단](#38-8-자바스크립트-파싱에-의한-html-파싱-중단)

---

## 38-1. 요청과 응답

-   브라우저의 주요 기능은 서버에게 필요한 리소스를 요청하고, 이를 받아 브라우저에서 시각적으로 렌더링하는 것이다
-   **필요한 리소스** ➡️ HTML, CSS, 자바스크립트, 이미지, 폰트 등의 정적 파일 or 서버가 동적으로 생성한 데이터
-   서버에게 요청을 보내기 위해 주소창에 URL을 입력하면 --> DNS통해 IP주소로 변경 --> 해당 IP주소를 갖는 서버에게 요청 전송
-   요청에 응답으로 서버는 HTML 파일을 보내주는데, 이 파일 안에서 `<script>`, `<style>` 태그 등 타 리소스가 필요한 경우 HTML 파일의 parsing 과정을 멈추고 타 리소스의 request --> parsing 과정을 우선 진행한다

<br>

## 38-2. HTTP 1.1과 HTTP 2.0

| 타입     | 커넥션 당 요청   | 특징                                                                                                          |
| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------- |
| HTTP 1.1 | 단일 요청만 가능 | 하나의 요청과 하나의 응답만 처리하기 때문에, 요청할 리소스의 개수에 비례하여 응답 시간도 증가하는 단점이 있다 |
| HTTP 2.0 | 다중 요청 가능   | 여러 리소스의 동시 전송이 가능하므로 HTTP 1.1에 비해 페이지 로드 속도가 약 50% 정도 빠름                      |

<br>

## 38-3. HTML 파싱과 DOM 생성

-   브라우저의 요청에 의해 서버로부터 전달된 HTML 문서는 문자열로 이루어진 순수한 텍스트일 뿐이다
-   이를 브라우저에 시각적인 픽셀로 렌더링하려면 HTML 문서를 브라우저가 이해할 수 있는 자료구조(객체)로 변환하여 저장해야 한다

```
💡HTML 파싱 과정 (서버 요청부터 DOM 생성까지의 흐름)

서버 ➡️ HTML 문서(2진수) ➡️ 2진수 문자(meta 태그 참고)로 변환 ➡️ 문자열 토큰으로 변환 ➡️ 각 토큰을 객체로 변환하여 노드 생성 ➡️ DOM 생성
```

-   즉, DOM(Document Object Model) HTML 문서를 파싱한 결과물이다

<br>

## 38-4. CSS 파싱과 CSSOM 생성

-   HTML을 한 줄씩 순차적으로 파싱하여 DOM을 생성하는 과정에서 CSS를 로드하는 `<link>`/`<style>` 태그를 만나게 되면 DOM 생성은 일시 중단된다
-   상황에 따라 href 어트리뷰터에 지정되어 있는 CSS 파일을 서버로부터 받아오거나, 스타일 태그 내부의 CSS를 HTML과 동일한 파싱 과정을 통해 해석하며 **CSSOM**(CSS Object Model)을 생성한다
-   CSSOM 생성이 완료되면 다시 중단된 지점부터 DOM 생성을 재개한다
-   CSSOM은 CSS의 상속을 반영하여 생성된다

<br>

## 38-5. 렌더 트리 생성

-   HTML 파싱을 통해 생성된 DOM, CSS 파싱을 통해 생성된 CSSOM은 렌더링을 위해 **렌더 트리**로 결합된다
-   렌더 트리는 렌더링을 위한 트리 구조의 자료구조이기 때문에 화면에 렌더링되지 않는 노드(eg. meta 태그, script 태그 등)와 CSS에 의해 비표시(eg. display:none)되는 노드들은 포함하지 않는다
-   렌더 트리는 각 HTML 요소의 레이아웃(location & size)을 계산하는데 사용되며 페인팅 처리에 입력된다
-   렌더링 과정은 반복해서 실행될 수 있다 (아래 참고)

```
💡레이아웃 계산과 페인팅이 재차 실행되는 Case

1. 자바스크립트에 의한 노드 추가/삭제
2. 브라우저 창의 리사이징에 의한 Viewport 크기 변경
3. HTML 요소의 레이아웃에 변경을 발생시키는 width/height, margin, padding 등의 변경
```

-   Re-rendering은 비용이 많이 드는, 성능에 악영향을 주는 작업이므로 가급적 빈번하게 발생하지 않도록 주의할 필요가 있다
    -   Re-

<br>

## 38-6. 자바스크립트 파싱과 실행

-   DOM은 HTML 문서의 구조와 정보뿐만 아니라 HTML 요소와 스타일을 변경할 수 있는 프로그래밍 인터페이스로서 DOM API를 제공한다 (39장 참고 요망)
-   `<style>` 태그, `<link>` 태그를 만났을 때처럼 HTML 파싱 과정에서 `<script>` 태그나 자바스크립트 콘텐츠를 만나면 DOM 생성을 일시 중단한다
-   이때 브라우저가 직접 자바스크립트 코드를 파싱/실행을 하지 않고, 내부적으로 구현되어있는 자바스크립트 엔진이 처리한다 (eg. Google Chrome --> V8 Engine)
-   자바스크립트 엔진은 자바스크립트 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행하는 역할을 한다
-   자바스크립트 엔진은 자바스크립트를 해석하여 **추상 구문 트리**(AST: Abstract Syntax Tree)를 생성한다
-   그리고 AST를 기반으로 인터프리터가 실행할 수 있는 중간 코드인 바이트코드를 생성하여 실행한다

```
💡자바스크립트 코드를 파싱하는 JS Engine 내부 흐름

자바스크립트 소스코드 ➡️ 토크나이저 ➡️ 토큰 ➡️ 파서 ➡️ AST ➡️ 바이트코드 생성기 ➡️ 바이트코드 ➡️ 인터프리터
```

<br>

## 38-8. 자바스크립트 파싱에 의한 HTML 파싱 중단

-   렌더링 엔진과 자바스크립트 엔진은 병렬적으로 파싱을 실행하지 않고 직렬적으로 파싱을 수행한다
-   따라서 스크립트 태그에 의해 HTML 파싱이 블로킹되어 DOM 생성이 지연될 수 있다
-   만약 자바스크립트로 DOM이나 CSSOM을 변경하는 DOM API를 사용할 경우 DOM이나 CSSOM이 이미 생성되어 있어야 한다 (문제 발생 가능)
-   `<body>` 요소 가장 아래에 자바스크립트를 위치시크는 것은 좋은 아이디어다

```
1. DOM 완성 전 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수 있음
2. 자바스크립트 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다
```
