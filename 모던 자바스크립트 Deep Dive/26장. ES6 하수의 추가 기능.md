# 26장: ES6 함수의 추가 기능

## 26-1. 함수의 구분 
- ES6 이전의 모든 함수는 callable이면서 constructor다
- 호출 방식에 의해 함수의 사용 방법이 달라진다는 것은 편리한 기능이라기 보다 실수를 유발시킬 수 있고 성능을 저하시키는 단점이다 (eg. 쓸모 없는 프로토타입 객체 생성)
- ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분한다 

| ES6 함수의 구분 | constructor | prototype | super | arguments |
| :------: | :------: | :------: | :------: | :------: | 
| 일반 함수 | O | O | X | O | 
| 메서드 | X | X | O | O |
| 화살표 함수 | X | X | X | X |

- 다시 복습해보자면 일반 함수는 함수 선언문, 함수 표현식으로 정의된 함수이며, ES6 이전과 차이가 없다 
- ES6 메서드와 화살표 함수에는 명확한 차이가 있다 (non-constructor)

<br>

## 26-2. 메서드 
> ES6 이전까지 메서드에 대한 명확한 정의는 없었다. 하지만 ES6 부터 메서드는 '메서드 축약 표현'으로 정의된 함수만을 의미한다 
```javascript 
const obj = { 
    x: 1,
    // 1. 메서드 축약 표현으로 정의된 메서드 
    methodFunction() {
        return this.x;
    },
    // 2. 메서드 아님 
    notMethodFunction: function() {
        return this.x;
    }
}
```
- 메서드는 non-constructor이므로 생성자 함수로서 호출할 수 없다 
- 따라서 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입 객체도 생성하지 않는다 
- 참고로 표준 빌트인 객체가 제공하는 프로토타입/정적 메서드 모두 non-constructor다 
- **ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObjet]]`를 갖는다
- `super` 참조는 내부 슬롯 `[[HomeObject]]`를 사용하여 수퍼클래스의 메서드를 참조하므로 ES6 메서드는 super 키워드를 사용할 수 있다 

<br>

## 26-3. 화살표 함수 
> 화살표 함수는 표현만 간략한 것이 아니라 내부 동작도 기본 함수보다 간략하다 
```
화살표 함수 vs 일반 함수 

1. 화살표 함수는 non-constructor다 
2. 화살표 함수는 중복된 매개변수 이름을 선어할 수 없다 
3. 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다 
```
- 화살표 함수 내부에서 this, arguments, super, new.target을 참조하면 스코프 체인을 통해 상위 스코프의 this, arguments, super, new.target을 참조한다 
- 특히 자체적인 this 바인딩이 없다는 점이 가장 큰 차별점이며, 화살표 함수가 다른 함수에게 인수로(콜백 함수) 전달되는 경우가 많은 이유기도 하다 