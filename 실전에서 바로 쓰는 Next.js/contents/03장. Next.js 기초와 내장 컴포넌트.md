# 3장: Next.js 기초와 내장 컴포넌트

## 3-1. 라우팅 시스템

- Next.js는 파일 기반 라우팅 시스템을 사용한다.
- `pages/` 디렉터리 안에 있는 모든 파일은 곧 애플리케이션의 페이지와 라우팅 규칙을 의미한다.
- 예시로 `pages` 디렉터리 안에 index.js, about.js, contact.js가 있다고 가정했을 때, 각 파일의 주소는 `/`, `/about`, `/contact`가 된다.
- `pages/` 디렉터리 안에 있는 모든 파일은 JSX를 반환하는 함수를 익스포트해야 한다. 그래야 서버에서 해당 함수를 실행하고 렌더링한 HTML 내용을 브라우저로 전송할 수 있다.
- 편리하게도, 라우팅 이름을 바꾸고 싶으면 (예: `/contact`에서 `/contact-me`로 수정하고 싶을 때) 단순히 파일 이름을 contact-me.js로 변경하면 Next.js가 자동으로 해준다.
- 라우팅 규칙을 계층적 구조로 만드는 것도 편리하다 (react-router-dom에서는 계층적 구조를 만들기 위해 children으로 각 element를 넘겨주던 방식 대비)

  ```
  pages/
    - index.js
    - contact-me.js
    - posts/
      - index.js
      - [slug].js

  ```
- 이제 해당 애플리케이션의 url + `/posts`로 접근하면, `posts/` 디렉터리 내부에 있는 index.js 파일에서 반환하는 페이지를 볼 수 있게 된다.
- `posts/` 디렉터리에 새로운 블로그 글을 작성할 때마다 수동으로 새 페이지를 만들지 않도록 하기 위해, 동적 라우팅 규칙을 생성할 수 있다.
    - `[slug]`는 경로 매개변수로 사용자가 브라우저 주소창에 입력하는 값은 모두 가질 수 있다. 즉, `[slug]`로 각 블로그 게시글을 구분할 수 있다.
    - `[slug].js` 파일에서 JSX 코드를 반환하는 간단한 함수를 익스포트하도록 만들면, url + `/my-firstpost` 같이 `pages/` 디렉터리 안에 없는 주소로도 접근할 수 있다.
- 동적 라우팅 규칙은 중첩될 수도 있다. 예를 들어 `posts/` 디렉터리에 있는 게시물을 `url/posts/[date]/[slug]` 주소로 접근하게끔 할 수 있다.

  ```
  pages/
  - index.js
  - contact-me.js
  - posts/
    - index.js
    - [date]/
      - [slug].js 

  ```
- `[date]` 디렉터리를 만들고, 그 안에 `[slug].js` 파일을 만들었기 때문에 각 게시물을 `url/2023-03-30/blogPost1`으로 접근할 수 있게 된다.
- 물론, 지금까지는 예제는 경로 매개변수를 사용해 똑같은 페이지를 렌더링하는 작업이다. 반대로 애플리케이션은 주로 경로 매개변수에 따라 서로 다른 동적 페이지를 렌더링할 수 있어야 한다.

### 페이지에서 경로 매개변수 사용하기
- `pages/greet/[name.js]` 구조로 되어있는 프로젝트가 있다고 가정해보자.
    - 이 페이지는 Next.js 내장 getServerSideProps 함수를 통해 url에서 동적으로 [name] 변수값을 가져와서 해당 사용자를 환영한다는 문구를 표시한다 (아래 예제 참고)

  ```js
  export async function getServerSideProps({ params }) {
    const { name } = params;

    return { props: { name } }; 
  }

  function Greet(props) {
    return (<h1> Hello, {props.name}! </h1>);
  }

  export default Greet; 
  ```

- `url/greet/Mitch` 주소로 가면 이제 'Hello, Mitch!'라는 문구가 보일 것이다.

### 컴포넌트에서 경로 매개변수 사용하기
- Next.js에서는 페이지 밖에서 getServerSideProps, getStaticProps 함수를 사용하지 못하기 때문에, 페이지가 아닌 컴포넌트에서 경로 매개변수를 사용하는 방법이 다르다.
- `useRouter` 훅을 사용하면 query 매개변수를 가져올 수 있다. query 매개변수에는 경로 매개변수와 분석된 쿼리 매개변수 문자열 값이 있다.

  ```js
  import { useRouter } from 'nextrouter';

  function Greet() {
    const { query } = useRouter();

    return (<h1> Hello, {query.name}! </h1>);
  }

  export default Greet;
  ```

- 위 예제의 경우 query 매개변수에 name 변수만 있다.
- 꼭 `[slug]`를 써야 useQuery를 통해 접근할 수 있는 것은 아니다. 위 코드의 반환문 전에 query 매개변수 전체를 console.log하고, `url/greet/Mitch?learning_nextjs=true`로 접근하면, 콘솔에 다음과 같은 값이 출력된다.
  
  ```js
  { learning_nextjs: "true", name: "Mitch } 
  ```

### 클라이언트에서의 내비게이션 
- Next.js는 웹 애플리케이션의 성능 최적화를 위해 많은 기능을 제공하는데, 그 중 하나가 클라이언트에서 내비게이션을 처리하는 것이다.
- (react-router-dom과 비슷하게) 일반 `<a>` 태그 대신 `<Link>`를 사용해 라우트 간의 이동을 최적화할 수 있다.

  ```js
  import Link from 'next/Link';

  function NavBar() {
    return (
      <div>
        <Link href='/about'>Home</Link>
        <Link href='/info'>Info</Link>
        <Link href='/contact' preload={false}>Contact</Link>
      </div>
    );
  }

  export default NavBar;
  ```

- Next.js는 기본적으로 화면에 표시되는 페이지의 모든 Link에 대해 연결된 부분/페이지를 모두 미리 읽어온다. 즉, 페이지의 링크를 클릭했을 때 브라우저는 해당 페이지를 화면에 표시하기 위해 필요한 모든 데이터를 이미 불러온 상태인 셈이다.
  - 물론 이렇게까지 할 필요 없는 페이지가 있을 확률이 높기 때문에 Link 컴포넌트에 `preload={false}` 속성을 전달해 이 기능을 비활성화할 수 있다.
- 동적 경로 매개변수를 Link 컴포넌트에 연결시키는 것도 매우 편리하다 (Next.js 10 이전에는 href, as 속성 두 개를 사용해야 했지만 현재는 href 속성만 사용해도 됨)

  ```js
  // 단순히 동적 경로 매개변수를 href 속성에 전달하면 Next.js가 알아서 처리한다 
  <Link href='/posts/2023-03-30/blogPost1'>First Blog Post</Link> 
  ```

- 복잡한 url을 사용한다면 href 속성에 객체 전달할 수 있다.

  ```js
  <Link
    href={{
      pathname: '/posts/[date]/[slug]',
      query: {
        date: '2023-03-30',
        slug: 'blogPost1',
        foo: 'bar',
      }
    }}
  >
    First Blog Post
  </Link> 
  ```

- 위 예제의 Link를 클릭하면 Next.js는 `url/posts/2023-03-30/blogPost1?foo=bar`라는 주소로 연결한다.

### router.push 메서드
- Next.js에서는 Link 컴포넌트 대신 useRouter 훅을 사용해서 다른 페이지로 이동할 수 있다.
- 사용자 클릭이 있어야만 지정된 페이지로 라우팅되는 Link 컴포넌트와 다르게, router.push를 사용하면 사용자를 다른 페이지로 강제할 수 있다. (에시로, 로그인된 사용자만 볼 수 있는 페이지가 있다면 로그인 여부를 확인한 후, 로그인되지 않은 경우 router.push 메서드를 호출해 사용자를 로그인 페이지로 강제할 수 있음)

  ```js
  useEffect(() => {
    if (!user) router.push('/login');
  }, [loggedIn]); 
  ```
